author: JeffreyWilkinson
core-version: >=5.1.9
created: 20150811170239254
dependents: 
description: message passing
list: readme license
plugin-type: plugin
source: https://github.com/buggyj/tw5-plugins
title: $:/plugins/bj/msg
type: application/json
version: 0.0.1

{
    "tiddlers": {
        "$:/bj/modules/widgets/msgwidget.js": {
            "text": "/*\\\ntitle: $:/bj/modules/widgets/msgwidget.js\ntype: application/javascript\nmodule-type: widget\n\nWidget base class\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n/*\nCreate a widget object as a basic for message widgets\n/*\nAdd a list of event listeners from an array [{type:,handler:},...]\n*/\nWidget.prototype.addIdEventListeners = function(listeners) {\n\tvar self = this;\n\t$tw.utils.each(listeners,function(listenerInfo) {\n\t\tself.addIdEventListener(listenerInfo.id,listenerInfo.handler,listenerInfo.aux,listenerInfo.dom_method);\n\t});\n};\n\nWidget.prototype.initialise = function(parseTreeNode,options) {\n\toptions = options || {};\n\t// Save widget info\n\tthis.parseTreeNode = parseTreeNode;\n\tthis.wiki = options.wiki;\n\tthis.parentWidget = options.parentWidget;\n\tthis.variablesConstructor = function() {};\n\tthis.variablesConstructor.prototype = this.parentWidget ? this.parentWidget.variables : {};\n\tthis.variables = new this.variablesConstructor();\n\tthis.document = options.document;\n\tthis.attributes = {};\n\tthis.children = [];\n\tthis.domNodes = [];\n\tthis.eventListeners = {};\n\tthis.eventTable = options.eventTable || action;//if ($tw.browser && options.eventTable)alert(options.eventTable[\"type\"]);\n\t// Hashmap of the widget classes\n\tif(!this.widgetClasses) {\n\t\tWidget.prototype.widgetClasses = $tw.modules.applyMethods(\"widget\");\n\t}\n};\n/*\nAdd a message event listener\n*/\n//bj should throw an error if action[id] already exists - should be unque otherwise it will cause an error\nWidget.prototype.addIdEventListener = function(id,handler,aux, dom_method) {\n\n\tvar self = this;\n\tvar newitem ={name:null,handle:null,next:null,aux:null, dom_method:null}\n\n\tif(typeof handler === \"string\") { // The handler is a method name on this widget\n\t\tnewitem.aux = aux; //data to be passed back to the user\n\t\tnewitem.handle= function(event, aux) {\n\t\t\treturn self[handler].call(self,event,aux);\n\t\t};\n\t\tnewitem.name = handler; //save name so we can del later\n\t\tnewitem.dom_method = dom_method;\n\n\t} else { // The handler is a function\n\t\tnewitem.handle = function(event) {\n\t\t\treturn handler.call(self,event);\n\t\t};\n\t}\n\tif (!action[id]) {\n\t\taction[id] = newitem;\n\t} else {\n\t\tvar next = action[id];\n\t\t    while (next.next) next = next.next;\n\t\t    next.next = newitem;\n\t}\n\t\n};\n\nWidget.prototype.delIdEventListeners = function(listeners) {\n\tvar self = this;\n\t//action = {}; return;\n\t$tw.utils.each(listeners,function(listenerInfo) {\n\t\tself.delIdEventListener(listenerInfo.id,listenerInfo.type,listenerInfo.handler);\n\t});\n};\n\nWidget.prototype.delIdEventListener = function(id,type,handler) {\n\tvar self = this;\n\n\tif (!action[id]) { alert (\"no entry found \"+id)\n\t\treturn;\n\t} else {\n\t\tvar next = action[id];\n\t\tif (typeof handler === \"string\") {//alert (\"str\"+handler)\n\t\t\tif (handler == next.name) {\n\t\t\t\t action[id] = next.next;\n\t\t\t\t if (action[id] == null) delete (action[id]);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\twhile (next.next) {\n\t\t\t\t\tif (handler == next.next.name) break;\n\t\t\t\t\tnext = next.next;\n\t\t\t\t}\n\t\t\t\tif (!next.next) {\n\t\t\t\t\talert(\"not found str\");return;\n\t\t\t\t\t}\n\n\t\t\t\tnext.next = next.next.next;\n\t\t\t\treturn;\t\t\t\t\n\n\t\t\t}\n\t\t} else \t{\n\t\t\tif (handler == next.handle) {\n\t\t\t\taction[id] = next.next;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\twhile (next.next) {\n\t\t\t\t\tif (handler == next.next.handle) break;\n\t\t\t\t\tnext = next.next;\n\t\t\t\t}\n\t\t\t\tif (!next.next) {//alert(\"not found \");return;\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\tnext.next = next.next.next;\n\t\t\t\treturn;\t\t\t\t\n\n\t\t\t}\n\t\t} \n\t}\n\t\n};\n\n\n\n\n/*\nDispatch an event to a widget. If the widget doesn't handle the event then it is also dispatched to the parent widget\n*/\nWidget.prototype.dispatchIdEvent = function(id, event) {\n\n\tvar listener = action[id], e, aux;\n\n\t//if (typeof event.$isRef === \"undefined\" || event.$isRef !== true) {\n\t\t//e = JSON.parse(JSON.stringify(event));//clone to stop unintentional linking thru object referencing\n\t//}\n\t//else \n\te = event;\n\n\twhile (listener) {\n\t\t\n\t\tlistener.handle(e,listener.aux);\n\t\t//pass thru dynamic content\n\n\t\tif(!listener.next) {\n\t\t\treturn true;\n\t\t}\n\t\tlistener = listener.next\n\t}\n\treturn true;\n};\nWidget.prototype.getTable = function () {\n\treturn action;\n}\nWidget.prototype.setTable = function () {\n\t action=Object.create(null);\n}\nWidget.prototype.resetTable = function () {\n\t action=eventTable;\n}\nvar eventTable=Object.create(null);\n\nvar action = eventTable;\n\nexports.msgwidget = Widget;\n\n$tw.msgwidgettable = action;\n\n})();\n",
            "title": "$:/bj/modules/widgets/msgwidget.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/mcore/modules/widgets/alert.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/alert.js\ntype: application/javascript\nmodule-type: widget\n\nReveal widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n//alert = function () {};\nvar count = 0;\nvar intra = \"alert\";\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar RevealWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nRevealWidget.prototype = new Widget();\n\n\nRevealWidget.prototype.handler = \"py\";\n\nRevealWidget.prototype.wtype = intra;\n\n/*\nRender this widget into the DOM\n*/\nRevealWidget.prototype.render = function(parent,nextSibling) {\n\tthis.here = {};\n\tthis.here.domNode = null;\n\tthis.here.isOpen = false;\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tvar tag = this.parseTreeNode.isBlock ? \"div\" : \"span\";\n\tif(this.revealTag && $tw.config.htmlUnsafeElements.indexOf(this.revealTag) === -1) {\n\t\ttag = this.revealTag;\n\t}\n\tvar domNode = this.document.createElement(tag);\n\tvar classes = this[\"class\"].split(\" \") || [];\n\tdomNode.className = classes.join(\" \");\n\tif(this.style) {\n\t\tdomNode.setAttribute(\"style\",this.style);\n\t}\n\tparent.insertBefore(domNode,nextSibling);\n\tthis.renderChildren(domNode,null);//if there is not a matching default then there will not be children - see execute.\n\n\tdomNode.setAttribute(\"hidden\",\"true\");\n\n\tthis.domNodes.push(domNode);//alert(\"ren\"+this.domNodes.length)\n\t/////////////\t\n\t//bj meditation: hid this name mangling with a method in base class\n\tcount++;\n\tthis[this.wtype+count] = this.handlesetvalEvent;\n\tthis.handlename = this.wtype+count;\n\t///////////\n\tdomNode.setAttribute(\"id\",this.handlename);//link the dom with the callback\n\tdomNode.setAttribute(\"data-event\",this.Id+\"/mtm-alert\");\n\t//the value fof domNode below is added by the reduce runtime to the table enties, when it add the replacement for handlesetvalEvent\n\t\n\tif (this.handler) this[this.handler] = $tw.modules.applyMethods(\"dom_method\")[this.handler];\n\t//bj addIdEventListeners adds callback function handleNavigateEvent to this widget instance with key = id/type\n\t// there will be a removeIdEventListeners ([{type: \"tm-navigate\", id:this.id}]) which widget calls on closing down\n\tif (this.Id) {\t//alert(\"set \"+this.Id+\"/mtm-popup\")\t\t\n\t\tthis.addIdEventListeners([\n\t\t\t{handler: this.handlename, id:this.Id+\"/mtm-alert\", aux:this.here, dom_method:this.handler}\n\t\t]);\n\t}\n};\n\n/*\nCompute the internal state of the widget\n*/\nRevealWidget.prototype.execute = function() {\n\t// Get our parameters\n\n\tthis.Id = this.getAttribute(\"recvOn\");\n\t\n\tthis.here.type = this.getAttribute(\"type\");\n\tthis.here.text = this.getAttribute(\"text\");\n\n\t\n\tthis[\"class\"] = this.getAttribute(\"class\",\"\");\n\tthis.style = this.getAttribute(\"style\",\"\");\n\tthis[\"default\"] = this.getAttribute(\"default\",\"\");\n\t\n\n\n\t// Construct the child widgets\n\tvar childNodes = this.parseTreeNode.children;//Note that when rending there can be no children\n\tthis.hasChildNodes = true;\n\tthis.makeChildWidgets(childNodes);\n};\n\n\n/*Remove any DOM nodes created by this widget or its children\n*/\nRevealWidget.prototype.removeChildDomNodes = function() {\n//alert(this.text+ \"dom remove\")\n\t// If this widget has directly created DOM nodes, delete them and exit. This assumes that any child widgets are contained within the created DOM nodes, which would normally be the case\n\t$tw.utils.each(this.children,function(childWidget) {\n\t\t\tchildWidget.removeChildDomNodes();\n\t\t});\n\tif(this.domNodes.length > 0) {\n\t\t$tw.utils.each(this.domNodes,function(domNode) {\n\t\t\tdomNode.parentNode.removeChild(domNode);\n\t\t});\n\t\tthis.domNodes = [];\n\t}\n\tthis.delIdEventListeners([\n\t\t{ handler: this.handlename, id:this.Id+\"/mtm-alert\"}\n\t]);\n};\n\n\nRevealWidget.prototype.handlesetvalEvent = function(event,aux) {\n\t//bj meditation: in the reduced case, the domnode with be passed here? or will be place in table?\n\t//the runtime will have to connect this up to the table up - better use table\n\tvar domNode = aux.domNode?aux.domNode:this.domNodes[0];\n\tthis[this.handler](event,aux, domNode);\n}\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nRevealWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn this.refreshChildren(changedTiddlers);\n\t}\n};\n\n\nexports[intra] = RevealWidget;//alert\n\n})();\n",
            "title": "$:/mcore/modules/widgets/alert.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/mcore/modules/widgets/alert_handler.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/alert_handler.js\ntype: application/javascript\nmodule-type: dom_method\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nexports[\"al\"] = function(upstream,here,domNode) {\nalert(\"alert is here\")\n};\n\n\n})();\n",
            "title": "$:/mcore/modules/widgets/alert_handler.js",
            "type": "application/javascript",
            "module-type": "dom_method"
        },
        "$:/core/modules/widgets/app-popup.js": {
            "text": "/*\\\ntitle: $:/core/modules/widgets/app-popup.js\ntype: application/javascript\nmodule-type: widget\n\nAction widget to send a message\n\n\\*/\n(function(){\n//alert = function () {};\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nvar count = 0;\n\nvar Widget = require(\"$:/mcore/modules/widgets/event.js\").event;\n\nvar SendMessageWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n\tthis.count = count++;\n};\n\nSendMessageWidget.prototype = new Widget();\n\nSendMessageWidget.prototype.etype = \"click\"\n\nSendMessageWidget.prototype.wtype = \"app-popup\";\n\nSendMessageWidget.prototype.handler = \"do-popup\";\n\nexports[\"app-popup\"] = SendMessageWidget;\n\n})();\n",
            "title": "$:/core/modules/widgets/app-popup.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/core/modules/widgets/app-submit.js": {
            "text": "/*\\\ntitle: $:/core/modules/widgets/app-submit.js\ntype: application/javascript\nmodule-type: widget\n\\*/\n(function(){\n//alert = function () {};\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nvar count = 0;\n\nvar Widget = require(\"$:/mcore/modules/widgets/event.js\").event;\n\nvar SendMessageWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n\tthis.count = count++;\n};\n\nSendMessageWidget.prototype = new Widget();\n\nSendMessageWidget.prototype.etype = \"submit\"\n\nSendMessageWidget.prototype.wtype = \"app-submit\"\n\nSendMessageWidget.prototype.handler =  \"do-submit\";\n\nSendMessageWidget.prototype.execute = function() {\n\tvar self = this;\t\n\tthis.here = Object.create(null);//hold the values for the dowmsteam dynamic\n\n\tthis.here.tiddler = this.getAttribute(\"tiddler\");\n\tthis.here[\"class\"] = this.getAttribute(\"class\",\"\");\n\n\tthis.here.tiddlerTitle = this.getVariable(\"currentTiddler\");\n\tthis.here.storyTiddler = this.getVariable(\"storyTiddler\");\n};\n\nexports[\"app-submit\"] = SendMessageWidget;\n\n})();\n",
            "title": "$:/core/modules/widgets/app-submit.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/core/modules/widgets/app-submit_dom.js": {
            "text": "/*\\\ntitle: $:/core/modules/widgets/app-submit_dom.js\ntype: application/javascript\nmodule-type: dom_method\n\\*/\n(function(){\nexports[\"do-submit\"] = function(upstream,here) {\n\t\n\tvar vals = $tw.domextra.serialize(upstream.domNode, upstream.e);\n\talert(JSON.stringify(vals))//$tw.wiki.setTiddlerData (here.tiddler,vals);\n};\n})();\n",
            "title": "$:/core/modules/widgets/app-submit_dom.js",
            "type": "application/javascript",
            "module-type": "dom_method"
        },
        "$:/core/modules/utils/dom/popup.js": {
            "text": "/*\\\ntitle: $:/core/modules/utils/dom/popup.js\ntype: application/javascript\nmodule-type: utils\n\nModule that creates a $tw.utils.Popup object prototype that manages popups in the browser\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n/*\nCreates a Popup object with these options:\n\trootElement: the DOM element to which the popup zapper should be attached\n*/\nvar Popup = function(options) {\n\toptions = options || {};\n\tthis.rootElement = options.rootElement || document.documentElement;\n\tthis.popups = []; // Array of {title:,wiki:,domNode:} objects - bj add msg\n\tthis.widgetmsg = $tw.msgwidgettable; \n};\n/*\nask if popped up\n*/\nPopup.prototype.isPoppedUp = function(domNode) {\n\t// Check if this popup is already active\n\tvar index = -1;\n\tfor(var t=0; t<this.popups.length; t++) {\n\t\t// this will be checked for later \n\t\tif(this.popups[t].domNode === domNode) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false;\n}\n/*\nTrigger a popup open or closed. Parameters are in a hashmap:\n\ttitle: title of the tiddler where the popup details are stored\n\tdomNode: dom node to which the popup will be positioned\n\twiki: wiki\n\tforce: if specified, forces the popup state to true or false (instead of toggling it)\n*/\nPopup.prototype.triggerPopup = function(options) {\n\t// Check if this popup is already active\n\tvar index = -1;\n\tfor(var t=0; t<this.popups.length; t++) {\n\t\tif(this.popups[t].title === options.title) {\n\t\t\tindex = t;\n\t\t}\n\t}\n\t// Compute the new state\n\tvar state = index === -1;\n\tif(options.force !== undefined) {\n\t\tstate = options.force;\n\t}\n\t \n\t// Show or cancel the popup according to the new state\n\tif(state) {\n\t\tthis.show(options);\n\t} else {\n\t\tthis.cancel(index);\n\t}\n};\n\nPopup.prototype.handleEvent = function(event) {\n\tif(event.type === \"click\") {\n\t\t// Find out what was clicked on\n\t\tvar info = this.popupInfo(event.target),\n\t\t\tcancelLevel = info.popupLevel - 1;\n\t\t// Don't remove the level that was clicked on if we clicked on a handle\n\t\tif(this.isPoppedUp(event.target)||info.isHandle) {\n\t\t\tcancelLevel++;\n\t\t}else \n\t\t// Cancel\n\t\tthis.cancel(cancelLevel);\n\t}\n};\n\n/*\nFind the popup level containing a DOM node. Returns:\npopupLevel: count of the number of nested popups containing the specified element\nisHandle: true if the specified element is within a popup handle\n*/\nPopup.prototype.popupInfo = function(domNode) {\n\tvar isHandle = false,\n\t\tpopupCount = 0,\n\t\tnode = domNode;\n\t// First check ancestors to see if we're within a popup handle\n\twhile(node) {\n\t\tif($tw.utils.hasClass(node,\"tc-popup-handle\")) {\n\t\t\tisHandle = true;\n\t\t\tpopupCount++;\n\t\t}\n\t\tif($tw.utils.hasClass(node,\"tc-popup-keep\")) {\n\t\t\tisHandle = true;\n\t\t}\n\t\tnode = node.parentNode;\n\t}\n\t// Then count the number of ancestor popups\n\tnode = domNode;\n\twhile(node) {\n\t\tif($tw.utils.hasClass(node,\"tc-popup\")) {\n\t\t\tpopupCount++;\n\t\t}\n\t\tnode = node.parentNode;\n\t}\n\tvar info = {\n\t\tpopupLevel: popupCount,\n\t\tisHandle: isHandle\n\t};\n\treturn info;\n};\nvar reduced = null;\nif (typeof $twmodules !== 'undefined') reduced = true;\n/*\nDisplay a popup by adding it to the stack\n*/\nPopup.prototype.show = function(options) {\n\t// Find out what was clicked on\n\tvar info = this.popupInfo(options.domNode);\n\t// Cancel any higher level popups\n\tthis.cancel(info.popupLevel);\n\t// Store the popup details\n\tthis.popups.push({ //add a msg option\n\t\ttitle: options.title,\n\t\twiki: options.wiki,\n\t\tmsg: options.msg,\n\t\tdomNode: options.domNode\n\t});\n\t// Set the state tiddler\n\t// BJ send as message instead if we have a 'msg' option\n\t// wiki not used to send msg\n\tif (options.msg) {\n\t\t//BJ meditation: we may need to create the message object as a tiddler \n\t\t//to persist - as the reciever may have been 'folded out of the widget tree'\n\t\tvar here = Object.create(null), \n\t\t\tdownsteamId = options.title+'/'+\"mtm-popup\";\n\t\there.text = \"(\" + options.domNode.offsetLeft + \",\" + options.domNode.offsetTop + \",\" + \n\t\t\t\t\toptions.domNode.offsetWidth + \",\" + options.domNode.offsetHeight + \")\";\t\n\t   reduced?$twmodules.dom_method.dispatchIdEvent(downsteamId,here):dispatchIdEvent(downsteamId,here);\t\n\t   //put the button into 'tc-popup-handle' mode\n\t\t$tw.utils.addClass(options.domNode,\"tc-popup-handle\");\n\t} else {\n\t\toptions.wiki.setTextReference(options.title,\n\t\t\t\t\"(\" + options.domNode.offsetLeft + \",\" + options.domNode.offsetTop + \",\" + \n\t\t\t\t\toptions.domNode.offsetWidth + \",\" + options.domNode.offsetHeight + \")\");\n\t\t// Add the click handler if we have any popups\n\t\n\n\t}\n\tif(this.popups.length > 0) {\n\t\tthis.rootElement.addEventListener(\"click\",this,true);\t\n\t}\n};\n\nvar dispatchIdEvent = function(id, event) {\n\tvar listener = $tw.msgwidgettable[id], domNode;\n\twhile (listener) {\n//alert(listener.name.substring(0, 2)) \n\n\t\t\n\t\tlistener.handle(event,listener.aux);\n\t\t//pass thru dynamic content\n\n\t\tif(!listener.next) {\n\t\t\treturn true;\n\t\t}\n\t\tlistener = listener.next\n\t}\n\treturn true;\n}; \n/*\nCancel all popups at or above a specified level or DOM node\nlevel: popup level to cancel (0 cancels all popups)\n*/\nPopup.prototype.cancel = function(level) {\n\tvar numPopups = this.popups.length;\n\tlevel = Math.max(0,Math.min(level,numPopups));\n\tfor(var t=level; t<numPopups; t++) {\n\t\tvar popup = this.popups.pop();\n\t\tif(popup.title) {\n\t\t\t//if not popup.msg\n\t\t\tif (!popup.msg) {\n\t\t\t\tpopup.wiki.deleteTiddler(popup.title);\n\t\t\t}\n\t\t\t// else  send a msg?\n\t\t\telse {\n\t\t\t\t//BJ meditation: we may need to create the message object as a tiddler \n\t\t\t\t//to persist - as the reciever may have been 'folded out of the widget tree'\n\t\t\t\tvar here = Object.create(null), \n\t\t\t\tdownsteamId = popup.title+'/'+\"mtm-popup\";\n\t\t\t\there.text = \"\";\n\t\t\t   reduced?$twmodules.dom_method.dispatchIdEvent(downsteamId,here):dispatchIdEvent(downsteamId,here);\t\n\t\t\t   \t//pull the button out of 'tc-popup-handle' mode\n\t\t\t\t$tw.utils.removeClass(popup.domNode,\"tc-popup-handle\");\n\t\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n\tif(this.popups.length === 0) {\n\t\tthis.rootElement.removeEventListener(\"click\",this,false);\n\t}\n};\n\n/*\nReturns true if the specified title and text identifies an active popup\n*/\nPopup.prototype.readPopupState = function(text) {\n\tvar popupLocationRegExp = /^\\((-?[0-9\\.E]+),(-?[0-9\\.E]+),(-?[0-9\\.E]+),(-?[0-9\\.E]+)\\)$/;\n\treturn popupLocationRegExp.test(text);\n};\n\nexports.Popup = Popup;\n\n})();\n",
            "title": "$:/core/modules/utils/dom/popup.js",
            "type": "application/javascript",
            "module-type": "utils"
        },
        "$:/core/modules/widgets/update-timetot.js": {
            "text": "/*\\\ntitle: $:/core/modules/widgets/update-timetot.js\ntype: application/javascript\nmodule-type: dom_method\n\n\\*/\n(function(){\nexports[\"update-timetot\"] = function(upstream,here) {\n\t\n\tvar serialize = function(form, evt, query){\n\t\tvar evt    = evt || window.event;\n\t\tvar target = evt.target || evt.srcElement || null;\n\t\tvar field;\n\t\tquery = query  || {};\n\t\tif(typeof form == 'object' && form.nodeName == \"FORM\"){\n\t\t\tfor(var i=form.elements.length-1; i>=0; i--){\n\t\t\t\tfield = form.elements[i];\n\t\t\t\tif(field.name && !field.disabled && field.type != 'file' && field.type != 'reset'){\n\t\t\t\t\tif(field.type == 'select-multiple'){\n\t\t\t\t\t\tfor(j=form.elements[i].options.length-1; j>=0; j--){\n\t\t\t\t\t\t\tif(field.options[j].selected){\n\t\t\t\t\t\t\t\tquery [field.name] =  field.options[j].value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((field.type != 'submit' && field.type != 'button') || target == field){\n\t\t\t\t\t\t\tif((field.type != 'checkbox' && field.type != 'radio') || field.checked){\n\t\t\t\t\t\t\t   query [field.name] = field.value;\n\t\t\t\t\t\t\t}   \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn query;\n\t}\n\tvar vals = serialize(upstream.domNode, upstream.e);\n\n\tvar self = this,\n        val= 0 + vals.timer2*vals.reps2 + vals.timer4*vals.reps4  + vals.timer3*vals.reps3;\n        upstream.domNode.x.value = val + \":00\"\n};\n})();\n",
            "title": "$:/core/modules/widgets/update-timetot.js",
            "type": "application/javascript",
            "module-type": "dom_method"
        },
        "$:/mcore/modules/widgets/event.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/event.js\ntype: application/javascript\nmodule-type: widget\n\nbase msg widget \n\n\\*/\n(function(){\n//alert = function () {};\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n//BJ meditation - maybe move to a startup module?\nif($tw.browser) {\n\t\t$tw.domextra = new $tw.utils.domextra();\n}\nvar count = 0;//used as part of the unique id for each widget\n\nvar intra = \"event\";\n\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar SendMessageWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n\tthis.count = count++;\n};\n\n/*\nInherit from the base widget class\n*/\nSendMessageWidget.prototype = new Widget();\n\nSendMessageWidget.prototype.wtype = intra;\n\nSendMessageWidget.prototype.etype = null;\n\nSendMessageWidget.prototype.handler = null;\n/*\nRender this widget into the DOM\n*/\nSendMessageWidget.prototype.render = function(parent,nextSibling) {\n\tthis.computeAttributes();\n\tthis.execute();\n\tif (this.handler) this[this.handler] = $tw.modules.applyMethods(\"dom_method\")[this.handler];\n\n};\n/*\nCompute the internal state of the widget\n*/\nSendMessageWidget.prototype.execute = function() {\n\tvar self = this;\n\n\t\n\tthis.here = Object.create(null);//hold the values for the dowmsteam dynamic\n;\n\t$tw.utils.each(this.attributes,function(attribute,name) {\n\t\tif(name.charAt(0) !== \"$\") {\n\t\t\tself.here[name] = attribute;\n\t\t}\n\t});\n\t\n\tif (!this.etype) this.etype = this.getAttribute(\"$event\",\"\");\n\tif (!this.handler) this.handler = this.getAttribute(\"$handle\",\"\");\n\t\n\tthis.here.tiddlerTitle = this.getVariable(\"currentTiddler\");\n\tthis.here.storyTiddler = this.getVariable(\"storyTiddler\");\n};\n\n/*\nRefresh the widget by ensuring our attributes are up to date\n*/\nSendMessageWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\treturn true;\n};\n\n/*Remove event handlers\n*/\nSendMessageWidget.prototype.removeChildDomNodes = function() {\n//no childern with this widget - just remove event handler\n\tthis.delIdEventListeners([\n\t\t{handler: this.handlename, id:this.id+'/'+ this.msgType}\n\t]);\n};\n/*\nInvoke the init action associated with this widget\n*/\nSendMessageWidget.prototype.invokeInitAction = function(triggeringWidget,event) { //use addIdEventListener\n// set up the static part of the upstream.- \n// receive the item to listen for\n// setup incomming messge\t\n\tthis.id = event.id;//incomming id\n\tthis.msgType = event.msgTypePreamble+this.etype;\n\t\n\t//expose the name of the handler in the central table\n\t\t/////////////\t\n\tthis[this.wtype+this.count] = this.handleEvent;\n\tthis.handlename = this.wtype+this.count;\n\t///////////\t\n\n\n\n//pass the state of the widget into the central table via here (as the upstream listener) - this is the dynamic structure.\n\nthis.addIdEventListeners([\n\t\t{id:this.id+'/'+this.msgType, handler: this.handlename, aux:this.here, dom_method:this.handler}\n\t]);\n\treturn this.etype;\n};\n/*\nInvoke the down stream action associated with receiving an upstream event\n*/\nSendMessageWidget.prototype.handleEvent = function(event,aux) {\n     //alert(event.domeNode+aux.popup)\n\t// invoke handler\n\tthis[this.handler](event,aux);\n\n}\n\nexports[intra] = SendMessageWidget;//event\n\n})();\n",
            "title": "$:/mcore/modules/widgets/event.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/mcore/modules/utils/dom/extra.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/utils/dom/extra.js\ntype: application/javascript\nmodule-type: utils\n\n\\*/\n(function(){\n\nvar DomExtra = function() {\n}\n\nDomExtra.prototype.serialize  = function(form, evt, query){\n\tvar evt    = evt || window.event;\n\tvar target = evt.target || evt.srcElement || null;\n\tvar field;\n\tquery = query  || {};\n\tif(typeof form == 'object' && form.nodeName == \"FORM\"){\n\t\tfor(var i=form.elements.length-1; i>=0; i--){\n\t\t\tfield = form.elements[i];\n\t\t\tif(field.name && !field.disabled && field.type != 'file' && field.type != 'reset'){\n\t\t\t\tif(field.type == 'select-multiple'){\n\t\t\t\t\tfor(j=form.elements[i].options.length-1; j>=0; j--){\n\t\t\t\t\t\tif(field.options[j].selected){\n\t\t\t\t\t\t\tquery [field.name] =  field.options[j].value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif((field.type != 'submit' && field.type != 'button') || target == field){\n\t\t\t\t\t\tif((field.type != 'checkbox' && field.type != 'radio') || field.checked){\n\t\t\t\t\t\t   query [field.name] = field.value;\n\t\t\t\t\t\t}   \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn query;\n}\n\nexports.domextra = DomExtra;\n\n})();\n",
            "title": "$:/mcore/modules/utils/dom/extra.js",
            "type": "application/javascript",
            "module-type": "utils"
        },
        "$:/mcore/modules/widgets/mform.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/mform.js\ntype: application/javascript\nmodule-type: widget\n\nButton widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar ButtonWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n\n};\n\n/*\nInherit from the base widget class\n*/\nButtonWidget.prototype = new Widget();\nvar count = 0;\n/*\nRender this widget into the DOM\n*/\nButtonWidget.prototype.render = function(parent,nextSibling) {\n\tvar self = this;\n\t\n\t// Remember parent\n\tthis.parentDomNode = parent;\n\t// Compute attributes and execute state\n\tthis.computeAttributes();\n\tthis.execute();\n\t// Create element\n\tvar tag = \"form\";\n\tif(this.buttonTag && $tw.config.htmlUnsafeElements.indexOf(this.buttonTag) === -1) {\n\t\ttag = this.buttonTag;\n\t}\n\tvar domNode = this.document.createElement(tag);\n\t// Assign classes\n\tvar classes = this[\"class\"].split(\" \") || [];\n\tclasses.push(\"event\");\n\tdomNode.className = classes.join(\" \");\n\t// Assign other attributes\n\tif(this.style) {\n\t\tdomNode.setAttribute(\"style\",this.style);\n\t}\n\tif(this.tooltip) {\n\t\tdomNode.setAttribute(\"title\",this.tooltip);\n\t}\n\tif(this[\"aria-label\"]) {\n\t\tdomNode.setAttribute(\"aria-label\",this[\"aria-label\"]);\n\t}\n\t//need to generate id for domnode and pass it to action setmessage widgets\n\t/////////////\t\n\tcount++;\n    this.domnodeId = \"fm\"+count;\n\t///////////\n\n\t\n\tdomNode.setAttribute(\"id\",this.domnodeId);//link the dom with the callback\n\n\t// Add a click event handler and send off our domNode (used to locate with popups)\n\tparent.insertBefore(domNode,nextSibling);\n\tthis.renderChildren(domNode,null);\n\tthis.domNodes.push(domNode);\n\t\n\tif (this.valuesfrom) {\n\t\t\tvar configOptions = $tw.wiki.getTiddlerData(this.valuesfrom,{}), i;\n\t\t\tfor (i in configOptions) {\n\t\t\t\ttry {\n\t\t\t\t\tparent.firstElementChild[i].value = configOptions[i];\n\t\t\t\t} catch (e) {\n\n\t\t\t\t} \n\t\t\t\t\n\t\t\t}\n\t}\n\tthis.events = this.invokeInitActions(this,{id:this.domnodeId, msgTypePreamble:\"mtm-\"});\n\t\n\tfor (var i =0;i < this.events.length;i++) {//alert(\"i\"+i+ this.events[i]); \n\t\t(function (z) {\n\t\tvar i = z;//for seperate closure\n\t\tdomNode.addEventListener(self.events[i],function (event) {\n\t\t\tif (event.cancelable) event.preventDefault();\n\t\t\tvar data = Object.create(null);\n\t\t\tdata.domNode = domNode;\n\t\t\tdata.e =event;\n\t\t\tdata.$isRef = true; //indicate that we are sending references to objects\n\t\t\tself.dispatchIdEvent(self.domnodeId+\"/mtm-\"+self.events[i],data);\t//alert(self.domnodeId+\"/mtm-\"+self.events[i]+\"--\"+index);\n\t\t\t\treturn true;\n\t\t},false);})(i);\n\t\tdomNode.setAttribute(\"data-event\"+i,this.events[i]);\t//this is used by the reduced runtime to link up events\n\t}\n\t\n\t// Insert element\n\n\n};\n\nButtonWidget.prototype.invokeInitActions = function(triggeringWidget,event) {\n\tvar events= [];\n\t// For each child widget\n\tfor(var t=0; t<this.children.length; t++) {\n\t\tvar child = this.children[t];\n\t\t// We need to pass the id and message type to each each child, which will\n\t\t// use them to register addIdEventListeners\n\t\t// after this we can then use the msg mechanism to send them messages using id/msg-type\n\t\tif(child.invokeInitAction) {\n\t\t\tvar e = child.invokeInitAction(triggeringWidget,event);\n\t\t\tif (events.indexOf(e) == -1) events.push(e);\n\t\t}\n\t}\n\treturn events;\n};\n/*\nWe don't allow actions to propagate because we trigger actions ourselves\n*/\nButtonWidget.prototype.allowActionPropagation = function() {\n\treturn false;\n};\n\nButtonWidget.prototype.getBoundingClientRect = function() {\n\treturn this.domNodes[0].getBoundingClientRect();\n};\n\n/*\nCompute the internal state of the widget\n*/\nButtonWidget.prototype.execute = function() {\n\t// Get attributes\n\tthis.valuesfrom = this.getAttribute(\"valuesfrom\")||null;\n\tthis.hover = this.getAttribute(\"hover\");\n\tthis[\"class\"] = this.getAttribute(\"class\",\"\");\n\tthis[\"aria-label\"] = this.getAttribute(\"aria-label\");\n\tthis.tooltip = this.getAttribute(\"tooltip\");\n\tthis.style = this.getAttribute(\"style\");\n\tthis.defaultSetValue = this.getAttribute(\"default\",\"\");\n\tthis.buttonTag = this.getAttribute(\"tag\");\n\t// Make child widgets\n\tthis.makeChildWidgets();\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nButtonWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\treturn this.refreshChildren(changedTiddlers);\n};\n\nexports.mform = ButtonWidget;\n\n})();\n",
            "title": "$:/mcore/modules/widgets/mform.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/core/modules/widgets/mbutton.js": {
            "text": "/*\\\ntitle: $:/core/modules/widgets/mbutton.js\ntype: application/javascript\nmodule-type: widget\n\nButton widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar ButtonWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n\n};\n\n/*\nInherit from the base widget class\n*/\nButtonWidget.prototype = new Widget();\nvar count = 0;\n/*\nRender this widget into the DOM\n*/\nButtonWidget.prototype.render = function(parent,nextSibling) {\n\tvar self = this;\n\t\n\t// Remember parent\n\tthis.parentDomNode = parent;\n\t// Compute attributes and execute state\n\tthis.computeAttributes();\n\tthis.execute();\n\t// Create element\n\tvar tag = \"button\";\n\tif(this.buttonTag && $tw.config.htmlUnsafeElements.indexOf(this.buttonTag) === -1) {\n\t\ttag = this.buttonTag;\n\t}\n\tvar domNode = this.document.createElement(tag);\n\t// Assign classes\n\tvar classes = this[\"class\"].split(\" \") || [];\n\tclasses.push(\"event\");\n\tdomNode.className = classes.join(\" \");\n\t// Assign other attributes\n\tif(this.style) {\n\t\tdomNode.setAttribute(\"style\",this.style);\n\t}\n\tif(this.tooltip) {\n\t\tdomNode.setAttribute(\"title\",this.tooltip);\n\t}\n\tif(this[\"aria-label\"]) {\n\t\tdomNode.setAttribute(\"aria-label\",this[\"aria-label\"]);\n\t}\n\t//need to generate id for domnode and pass it to action setmessage widgets\n\t/////////////\t\n\tcount++;\n    this.domnodeId = \"bt\"+count;\n\t///////////\n\n\t\n\tdomNode.setAttribute(\"id\",this.domnodeId);//link the dom with the callback\n\n\t// Add a click event handler and send off our domNode (used to locate with popups)\n\tparent.insertBefore(domNode,nextSibling);\n\tthis.renderChildren(domNode,null);\n\tthis.domNodes.push(domNode);\n\n\tthis.events = this.invokeInitActions(this,{id:this.domnodeId, msgTypePreamble:\"mtm-\"});\n\t\n\tfor (var i =0;i < this.events.length;i++) {//alert(\"i\"+i+ this.events[i]); \n\t\t(function (z) {\n\t\tvar i = z;//for seperate closure\n\t\tdomNode.addEventListener(self.events[i],function (event) {\n\t\t\tvar data = Object.create(null);\n\t\t\tdata.domNode = domNode;\n\t\t\tdata.$isRef = true; //indicate that we are sending references to objects\n\t\t\tself.dispatchIdEvent(self.domnodeId+\"/mtm-\"+self.events[i],data);\t//alert(self.domnodeId+\"/mtm-\"+self.events[i]+\"--\"+index);\n\t\t\t\treturn true;\n\t\t},false);})(i);\n\n\n\t\tdomNode.setAttribute(\"data-event\"+i,this.events[i]);\n\t}\n\t// Insert element\n\n\n};\n\nButtonWidget.prototype.invokeInitActions = function(triggeringWidget,event) {\n\tvar events= [];\n\t// For each child widget\n\tfor(var t=0; t<this.children.length; t++) {\n\t\tvar child = this.children[t];\n\t\t// We need to pass the id and message type to each each child, which will\n\t\t// use them to register addIdEventListeners\n\t\t// after this we can then use the msg mechanism to send them messages using id/msg-type\n\t\tif(child.invokeInitAction) {\n\t\t\tvar e = child.invokeInitAction(triggeringWidget,event);\n\t\t\tif (events.indexOf(e) == -1) events.push(e);\n\t\t}\n\t}\n\treturn events;\n};\n/*\nWe don't allow actions to propagate because we trigger actions ourselves\n*/\nButtonWidget.prototype.allowActionPropagation = function() {\n\treturn false;\n};\n\nButtonWidget.prototype.getBoundingClientRect = function() {\n\treturn this.domNodes[0].getBoundingClientRect();\n};\n\n/*\nCompute the internal state of the widget\n*/\nButtonWidget.prototype.execute = function() {\n\t// Get attributes\n\n\tthis.hover = this.getAttribute(\"hover\");\n\tthis[\"class\"] = this.getAttribute(\"class\",\"\");\n\tthis[\"aria-label\"] = this.getAttribute(\"aria-label\");\n\tthis.tooltip = this.getAttribute(\"tooltip\");\n\tthis.style = this.getAttribute(\"style\");\n\tthis.defaultSetValue = this.getAttribute(\"default\",\"\");\n\tthis.buttonTag = this.getAttribute(\"tag\");\n\t// Make child widgets\n\tthis.makeChildWidgets();\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nButtonWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\treturn this.refreshChildren(changedTiddlers);\n};\n\nexports.mbutton = ButtonWidget;\n\n})();\n",
            "title": "$:/core/modules/widgets/mbutton.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/mcore/modules/widgets/mpreveal.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/mpreveal.js\ntype: application/javascript\nmodule-type: widget\n\nReveal widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n//alert = function () {};\nvar count = 0;\nvar intra = \"mpreveal\";\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar RevealWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nRevealWidget.prototype = new Widget();\n\n\nRevealWidget.prototype.handler = \"pr\";\n\nRevealWidget.prototype.wtype = intra;\n\n/*\nRender this widget into the DOM\n*/\nRevealWidget.prototype.render = function(parent,nextSibling) {\n\tthis.here = {};\n\tthis.here.domNode = null;\n\tthis.here.isOpen = false;\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tvar tag = this.parseTreeNode.isBlock ? \"div\" : \"span\";\n\tif(this.revealTag && $tw.config.htmlUnsafeElements.indexOf(this.revealTag) === -1) {\n\t\ttag = this.revealTag;\n\t}\n\tvar domNode = this.document.createElement(tag);\n\tvar classes = this[\"class\"].split(\" \") || [];\n\tclasses.push(\"tc-reveal\");\n\tdomNode.className = classes.join(\" \");\n\tif(this.style) {\n\t\tdomNode.setAttribute(\"style\",this.style);\n\t}\n\tparent.insertBefore(domNode,nextSibling);\n\tthis.renderChildren(domNode,null);//if there is not a matching default then there will not be children - see execute.\n\n\tdomNode.setAttribute(\"hidden\",\"true\");\n\n\tthis.domNodes.push(domNode);//alert(\"ren\"+this.domNodes.length)\n\t/////////////\t\n\t//bj meditation: hid this name mangling with a method in base class\n\tcount++;\n\tthis[this.wtype+count] = this.handlesetvalEvent;\n\tthis.handlename = this.wtype+count;\n\t///////////\n\tdomNode.setAttribute(\"id\",this.handlename);//link the dom with the callback\n\tdomNode.setAttribute(\"data-event\",this.Id+\"/mtm-popup\");\n\t//the value fof domNode below is added by the reduce runtime to the table enties, when it add the replacement for handlesetvalEvent\n\t\n\tif (this.handler) this[this.handler] = $tw.modules.applyMethods(\"dom_method\")[this.handler];\n\t//bj addIdEventListeners adds callback function handleNavigateEvent to this widget instance with key = id/type\n\t// there will be a removeIdEventListeners ([{type: \"tm-navigate\", id:this.id}]) which widget calls on closing down\n\tif (this.Id) {\t//alert(\"set \"+this.Id+\"/mtm-popup\")\t\t\n\t\tthis.addIdEventListeners([\n\t\t\t{handler: this.handlename, id:this.Id+\"/mtm-popup\", aux:this.here, dom_method:this.handler}\n\t\t]);\n\t}\n};\n\n/*\nCompute the internal state of the widget\n*/\nRevealWidget.prototype.execute = function() {\n\t// Get our parameters\n\n\tthis.Id = this.getAttribute(\"recvOn\");\n\tthis.revealTag = this.getAttribute(\"tag\");\n\t\n\tthis.here.type = this.getAttribute(\"type\");\n\tthis.here.text = this.getAttribute(\"text\");\n\tthis.here.position = this.getAttribute(\"position\");\n\t\n\tthis[\"class\"] = this.getAttribute(\"class\",\"\");\n\tthis.style = this.getAttribute(\"style\",\"\");\n\tthis[\"default\"] = this.getAttribute(\"default\",\"\");\n\t\n\tthis.animate = this.getAttribute(\"animate\",\"no\");\n\tthis.here.openAnimation = this.animate === \"no\" ? undefined : \"open\";\n\tthis.here.closeAnimation = this.animate === \"no\" ? undefined : \"close\";\n\n\n\t// Construct the child widgets\n\tvar childNodes = this.parseTreeNode.children;//Note that when rending there can be no children\n\tthis.hasChildNodes = true;\n\tthis.makeChildWidgets(childNodes);\n};\n\n\n/*Remove any DOM nodes created by this widget or its children\n*/\nRevealWidget.prototype.removeChildDomNodes = function() {\n//alert(this.text+ \"dom remove\")\n\t// If this widget has directly created DOM nodes, delete them and exit. This assumes that any child widgets are contained within the created DOM nodes, which would normally be the case\n\t$tw.utils.each(this.children,function(childWidget) {\n\t\t\tchildWidget.removeChildDomNodes();\n\t\t});\n\tif(this.domNodes.length > 0) {\n\t\t$tw.utils.each(this.domNodes,function(domNode) {\n\t\t\tdomNode.parentNode.removeChild(domNode);\n\t\t});\n\t\tthis.domNodes = [];\n\t}\n\tthis.delIdEventListeners([\n\t\t{ handler: this.handlename, id:this.Id+\"/mtm-popup\"}\n\t]);\n};\n\n\nRevealWidget.prototype.handlesetvalEvent = function(event,aux) {\n\t//bj meditation: in the reduced case, the domnode with be passed here? or will be place in table?\n\t//the runtime will have to connect this up to the table up - better use table\n\tvar domNode = aux.domNode?aux.domNode:this.domNodes[0];\n\tthis[this.handler](event,aux, domNode);\n}\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nRevealWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn this.refreshChildren(changedTiddlers);\n\t}\n};\n\n\nexports[intra] = RevealWidget;//mpreveal\n\n})();\n",
            "title": "$:/mcore/modules/widgets/mpreveal.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/mcore/modules/widgets/mpreveal_handler.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/mpreveal_handler.js\ntype: application/javascript\nmodule-type: dom_method\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nexports[\"pr\"] = function(upstream,here,domNode) {\n\t//note there is a major hack to pass in the domNode that is different in the full and reduced code base.\n\tvar popup = readPopupState(upstream.text);\n\tif (popup) {\n\t// Animate our DOM node\n\t\tpositionPopup(domNode,popup,here.position);\n\t\t$tw.utils.addClass(domNode,\"tc-popup\"); // Make sure that clicks don't dismiss popups within the revealed content\n\t\tdomNode.removeAttribute(\"hidden\");\n\t\tif (typeof $tw !== \"undefined\" && $tw.anim) $tw.anim.perform(here.openAnimation,domNode);\n\t} else {\n\t\tif (typeof $tw !== \"undefined\" && $tw.anim) {\n\t\t\t$tw.anim.perform(here.closeAnimation,domNode,{callback: function() {\n\t\t\t\tdomNode.setAttribute(\"hidden\",\"true\");\n\t\t\t}});\n\t\t} else domNode.setAttribute(\"hidden\",\"true\");\n\n\t} \n\n};\n\nvar positionPopup = function(domNode,popup,position) {\n\tdomNode.style.position = \"absolute\";\n\tdomNode.style.zIndex = \"1000\";\n\tswitch(position) {\n\t\tcase \"left\":\n\t\t\tdomNode.style.left = (popup.left - domNode.offsetWidth) + \"px\";\n\t\t\tdomNode.style.top = popup.top + \"px\";\n\t\t\tbreak;\n\t\tcase \"above\":\n\t\t\tdomNode.style.left = popup.left + \"px\";\n\t\t\tdomNode.style.top = (popup.top - domNode.offsetHeight) + \"px\";\n\t\t\tbreak;\n\t\tcase \"aboveright\":\n\t\t\tdomNode.style.left = (popup.left + popup.width) + \"px\";\n\t\t\tdomNode.style.top = (popup.top + popup.height - domNode.offsetHeight) + \"px\";\n\t\t\tbreak;\n\t\tcase \"right\":\n\t\t\tdomNode.style.left = (popup.left + popup.width) + \"px\";\n\t\t\tdomNode.style.top = popup.top + \"px\";\n\t\t\tbreak;\n\t\tcase \"belowleft\":\n\t\t\tdomNode.style.left = (popup.left + popup.width - domNode.offsetWidth) + \"px\";\n\t\t\tdomNode.style.top = (popup.top + popup.height) + \"px\";\n\t\t\tbreak;\n\t\tcase \"belowcenter\":\n\t\t\tdomNode.style.left = (popup.left + popup.width - domNode.offsetWidth)/2 + \"px\";\n\t\t\tdomNode.style.top = (popup.top + popup.height) + \"px\";\n\t\t\tbreak;\n\t\tdefault: // Below\n\t\t\tdomNode.style.left = popup.left + \"px\";\n\t\t\tdomNode.style.top = (popup.top + popup.height) + \"px\";\n\t\t\tbreak;\n\t}\n}\nvar readPopupState = function(state) {\n\tvar popupLocationRegExp = /^\\((-?[0-9\\.E]+),(-?[0-9\\.E]+),(-?[0-9\\.E]+),(-?[0-9\\.E]+)\\)$/,\n\t\tmatch = popupLocationRegExp.exec(state);\n\t// Check if the state matches the location regexp\n\t// BJ if state looks like a location\n\tif(match) {\n\t\t// If so, we're open\n\t\t// Get the location\n\t\treturn  {\n\t\t\tleft: parseFloat(match[1]),\n\t\t\ttop: parseFloat(match[2]),\n\t\t\twidth: parseFloat(match[3]),\n\t\t\theight: parseFloat(match[4])\n\t\t};\n\t\t \n\t} else {\n\t\treturn null;\n\t}\n};\n})();\n",
            "title": "$:/mcore/modules/widgets/mpreveal_handler.js",
            "type": "application/javascript",
            "module-type": "dom_method"
        },
        "$:/mcore/modules/widgets/mreveal.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/mreveal.js\ntype: application/javascript\nmodule-type: widget\n\nReveal widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n//alert = function () {};\nvar count = 0;\nvar intra = \"mreveal\";\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar RevealWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n\tthis.count = count++;\n};\n\n/*\nInherit from the base widget class\n*/\nRevealWidget.prototype = new Widget();\n\n\nRevealWidget.prototype.handler = \"rv\";\n\nRevealWidget.prototype.wtype = intra;\n/*\nRender this widget into the DOM\n*/\nRevealWidget.prototype.render = function(parent,nextSibling) {\n\t//BJ meditation: we may use some type of memory to cache the state of a widget in the future and read statea from there.\n\tthis.statea = null;\n\tthis.isOpen = false;\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tvar tag = this.parseTreeNode.isBlock ? \"div\" : \"span\";\n\tif(this.revealTag && $tw.config.htmlUnsafeElements.indexOf(this.revealTag) === -1) {\n\t\ttag = this.revealTag;\n\t}\n\tvar domNode = this.document.createElement(tag);\n\tvar classes = this[\"class\"].split(\" \") || [];\n\tclasses.push(\"tc-reveal\");\n\tdomNode.className = classes.join(\" \");\n\tif(this.style) {\n\t\tdomNode.setAttribute(\"style\",this.style);\n\t}\n\tparent.insertBefore(domNode,nextSibling);\n\tthis.renderChildren(domNode,null);//if there is not a matching default then there will not be children - see execute.\n\n\tif(!this.toOpen) {\n\t\tdomNode.setAttribute(\"hidden\",\"true\");\n\t}\n\tthis.domNodes.push(domNode);//alert(\"ren\"+this.domNodes.length)\n\tthis.isOpen = this.toOpen;\n\t/////////////\t\n\t//bj meditation: hid this name mangling with a method in base class\n\n\tthis[this.wtype+this.count] = this.handlesetvalEvent;\n\tthis.handlename = this.wtype+this.count;\n\t///////////\n\tdomNode.setAttribute(\"id\",this.handlename);//link the dom with the callback\n\tdomNode.setAttribute(\"data-event\",this.Id+\"/mtm-compare\");\n\t//the value fof domNode below is added by the reduce runtime to the table enties, when it add the replacement for handlesetvalEvent\n\tif (this.handler) this[this.handler] = $tw.modules.applyMethods(\"dom_method\")[this.handler];\n\tvar aux = {domNode:null,isOpen:this.isOpen, type:this.type, text:this.text,closeAnimation:this.closeAnimation,openAnimation:this.openAnimation};\n\t//bj addIdEventListeners adds callback function handleNavigateEvent to this widget instance with key = id/type\n\t// there will be a removeIdEventListeners ([{type: \"tm-navigate\", id:this.id}]) which widget calls on closing down\n\tif (this.Id) {\t\t\t\n\t\tthis.addIdEventListeners([\n\t\t\t{handler: this.handlename, id:this.Id+\"/mtm-compare\", aux:aux, dom_method:this.handler}\n\t\t]);\n\t}\n};\n\n/*\nCompute the internal state of the widget\n*/\nRevealWidget.prototype.execute = function() {\n\t// Get our parameters\n\n\tthis.state = this.getAttribute(\"state\");\n\tthis.Id = this.getAttribute(\"recvOn\");\n\tthis.revealTag = this.getAttribute(\"tag\");\n\tthis.type = this.getAttribute(\"type\");\n\tthis.text = this.getAttribute(\"text\");\n\tthis.position = this.getAttribute(\"position\");\n\tthis[\"class\"] = this.getAttribute(\"class\",\"\");\n\tthis.style = this.getAttribute(\"style\",\"\");\n\tthis[\"default\"] = this.getAttribute(\"default\",\"\");\n\tthis.animate = this.getAttribute(\"animate\",\"no\");\n\tthis.openAnimation = this.animate === \"no\" ? undefined : \"open\";\n\tthis.closeAnimation = this.animate === \"no\" ? undefined : \"close\";\n\t// Compute the title of the state tiddler and read it\n\tthis.stateTitle = this.state;\n\tthis.toOpen = this.readState();\n\n\t// Construct the child widgets\n\tvar childNodes = this.parseTreeNode.children;//Note that when rending there can be no children\n\tthis.hasChildNodes = true;\n\tthis.makeChildWidgets(childNodes);\n};\n\n\n/*Remove any DOM nodes created by this widget or its children\n*/\nRevealWidget.prototype.removeChildDomNodes = function() {\n//alert(this.text+ \"dom remove\")\n\t// If this widget has directly created DOM nodes, delete them and exit. This assumes that any child widgets are contained within the created DOM nodes, which would normally be the case\n\t$tw.utils.each(this.children,function(childWidget) {\n\t\t\tchildWidget.removeChildDomNodes();\n\t\t});\n\tif(this.domNodes.length > 0) {\n\t\t$tw.utils.each(this.domNodes,function(domNode) {\n\t\t\tdomNode.parentNode.removeChild(domNode);\n\t\t});\n\t\tthis.domNodes = [];\n\t}\n\tthis.delIdEventListeners([\n\t\t{ handler: this.handlename, id:this.Id+\"/mtm-compare\"}\n\t]);\n};\n/*\nRead the state tiddler\n*/\nRevealWidget.prototype.readState = function() {\n\t// Read the information from the state tiddler\n\tvar state, toOpen;\n\tif (this.statea) {\n\t\tstate = this.statea;// this.statea = null;\n\t}\n\telse\n\t  state = this[\"default\"];\n\t  \n\tswitch(this.type) {\n\t\tcase \"match\":\n\t\t\ttoOpen = state === this.text;\n\t\t\tbreak;\n\t\tcase \"nomatch\":\n\t\t\ttoOpen = state === this.text;\n\t\t\ttoOpen  = !toOpen;\n\t\t\tbreak;\n\t}\n\treturn toOpen;\n};\n\n\nRevealWidget.prototype.handlesetvalEvent = function(event,aux) {\n\t//bj meditation: in the reduced case, the domnode with be passed here? or will be place in table?\n\t//the runtime will have to connect this up to the table up - better use table\n\tvar domNode = aux.domNode?aux.domNode:this.domNodes[0];\n\tthis[this.handler](event,aux, domNode);\n}\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nRevealWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn this.refreshChildren(changedTiddlers);\n\t}\n};\n\n/*\nCalled by refresh() to dynamically show or hide the content\n*/\nRevealWidget.prototype.updateState = function() {//alert(\"update \"+this.domNodes.length)\n\n\tvar domNode = this.domNodes[0];\n\t// Animate our DOM node\n\tif(!this.isOpen) {\n\t\tdomNode.removeAttribute(\"hidden\");\n        $tw.anim.perform(this.openAnimation,domNode);\n        this.isOpen = true;\n\t} else {\n\t\t$tw.anim.perform(this.closeAnimation,domNode,{callback: function() {\n\t\t\tdomNode.setAttribute(\"hidden\",\"true\");\n        }});\n        this.isOpen = false;\n\t}\n};\n\nexports[intra] = RevealWidget;//mreveal\n\n})();\n",
            "title": "$:/mcore/modules/widgets/mreveal.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/mcore/modules/widgets/mreveal_handler.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/mreveal_handler.js\ntype: application/javascript\nmodule-type: dom_method\n\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nexports[\"rv\"] = function(upstream,here,domNode) {\n\tvar state = upstream.paramObject.state;//upstream.paramObject.state is the changed state (in a string) sent to use from the source.\n\tvar refreshed = false,\n\t\ttoOpen;\n\t\n\tswitch(here.type) {\n\t\tcase \"match\":\n\t\t\ttoOpen = state === here.text;//alert(state+\" state M toopen=\"+toOpen);\n\t\t\tbreak;\n\t\tcase \"nomatch\":\n\t\t\ttoOpen = state === here.text;//alert(state+\" state noM toopen\"+toOpen);\n\t\t\ttoOpen = !toOpen;\n\t\t\tbreak;\n\t}\n\tif(toOpen !== here.isOpen) {\n\n\t\t\n\t\t// Animate our DOM node\n\t\tif(!here.isOpen) {\n\t\t\tdomNode.removeAttribute(\"hidden\");\n\t\t\tif (typeof $tw !== \"undefined\" && $tw.anim) $tw.anim.perform(here.openAnimation,domNode);\n\t\t\there.isOpen = true;\n\t\t} else {\n\t\t\tif (typeof $tw !== \"undefined\" && $tw.anim) {\n\t\t\t\t$tw.anim.perform(here.closeAnimation,domNode,{callback: function() {\n\t\t\t\t\tdomNode.setAttribute(\"hidden\",\"true\");\n\t\t\t\t}});\n\t\t\t} else domNode.setAttribute(\"hidden\",\"true\");\n\t\t\there.isOpen = false;\n\t\t} \n\t\t\n\t} else {}//alert(state+\" state M isopen\"+this.isOpen +\" toopen\"+toOpen+\"text\"+this.text);}\n};\n\n\n})();\n",
            "title": "$:/mcore/modules/widgets/mreveal_handler.js",
            "type": "application/javascript",
            "module-type": "dom_method"
        },
        "$:/core/modules/widgets/msgexport.js": {
            "text": "/*\\\ntitle: $:/core/modules/widgets/msgexport.js\ntype: application/javascript\nmodule-type: widget\n\ncreate a json tiddler containing the msg table\n* \n\\*/\n(function(){\n//var count = 0;\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar SendMessageWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nSendMessageWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nSendMessageWidget.prototype.render = function(parent,nextSibling) {\n\tthis.computeAttributes();\n\tthis.execute();\n\tvar\tfields = {\n\t\t\t\ttitle: this.tiddler,\n\t\t\t\ttext: JSON.stringify(this.getTable(),null,$tw.config.preferences.jsonSpaces)\n\t\t\t\n\t\t\t};\n\t//create a json tiddler containing the msg table\n\t//count++;\n\tthis.wiki.addTiddler(new $tw.Tiddler(fields));\n};\n\n/*\nCompute the internal state of the widget\n*/\nSendMessageWidget.prototype.execute = function() {\n\tthis.tiddler = this.getAttribute(\"tiddler\");\n\n};\n\n/*\nRefresh the widget by ensuring our attributes are up to date\n*/\nSendMessageWidget.prototype.refresh = function(changedTiddlers) {\n\n\treturn this.refreshChildren(changedTiddlers);\n};\n\n\n\nexports[\"msgexport\"] = SendMessageWidget;\n\n})();\n",
            "title": "$:/core/modules/widgets/msgexport.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/mcore/modules/widgets/play.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/play.js\ntype: application/javascript\nmodule-type: widget\n\nReveal widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n//alert = function () {};\nvar count = 0;\nvar intra = \"play\";\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar RevealWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nRevealWidget.prototype = new Widget();\n\n\nRevealWidget.prototype.handler = \"py\";\n\nRevealWidget.prototype.wtype = intra;\n\n/*\nRender this widget into the DOM\n*/\nRevealWidget.prototype.render = function(parent,nextSibling) {\n\tthis.here = {};\n\tthis.here.domNode = null;\n\tthis.here.isOpen = false;\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tvar tag = this.parseTreeNode.isBlock ? \"div\" : \"span\";\n\tif(this.revealTag && $tw.config.htmlUnsafeElements.indexOf(this.revealTag) === -1) {\n\t\ttag = this.revealTag;\n\t}\n\tvar domNode = this.document.createElement(tag);\n\tvar classes = this[\"class\"].split(\" \") || [];\n\tdomNode.className = classes.join(\" \");\n\tif(this.style) {\n\t\tdomNode.setAttribute(\"style\",this.style);\n\t}\n\tparent.insertBefore(domNode,nextSibling);\n\tthis.renderChildren(domNode,null);//if there is not a matching default then there will not be children - see execute.\n\n\tdomNode.setAttribute(\"hidden\",\"true\");\n\n\tthis.domNodes.push(domNode);//alert(\"ren\"+this.domNodes.length)\n\t/////////////\t\n\t//bj meditation: hid this name mangling with a method in base class\n\tcount++;\n\tthis[this.wtype+count] = this.handlesetvalEvent;\n\tthis.handlename = this.wtype+count;\n\t///////////\n\tdomNode.setAttribute(\"id\",this.handlename);//link the dom with the callback\n\tdomNode.setAttribute(\"data-event\",this.Id+\"/mtm-play\");\n\t//the value fof domNode below is added by the reduce runtime to the table enties, when it add the replacement for handlesetvalEvent\n\t\n\tif (this.handler) this[this.handler] = $tw.modules.applyMethods(\"dom_method\")[this.handler];\n\t//bj addIdEventListeners adds callback function handleNavigateEvent to this widget instance with key = id/type\n\t// there will be a removeIdEventListeners ([{type: \"tm-navigate\", id:this.id}]) which widget calls on closing down\n\tif (this.Id) {\t//alert(\"set \"+this.Id+\"/mtm-popup\")\t\t\n\t\tthis.addIdEventListeners([\n\t\t\t{handler: this.handlename, id:this.Id+\"/mtm-play\", aux:this.here, dom_method:this.handler}\n\t\t]);\n\t}\n};\n\n/*\nCompute the internal state of the widget\n*/\nRevealWidget.prototype.execute = function() {\n\t// Get our parameters\n\n\tthis.Id = this.getAttribute(\"recvOn\");\n\t\n\tthis.here.type = this.getAttribute(\"type\");\n\tthis.here.text = this.getAttribute(\"text\");\n\tthis.revealTag = this.getAttribute(\"tag\");\n\n\t\n\tthis[\"class\"] = this.getAttribute(\"class\",\"\");\n\tthis.style = this.getAttribute(\"style\",\"\");\n\tthis[\"default\"] = this.getAttribute(\"default\",\"\");\n\t\n\n\n\t// Construct the child widgets\n\tvar childNodes = this.parseTreeNode.children;//Note that when rending there can be no children\n\tthis.hasChildNodes = true;\n\tthis.makeChildWidgets(childNodes);\n};\n\n\n/*Remove any DOM nodes created by this widget or its children\n*/\nRevealWidget.prototype.removeChildDomNodes = function() {\n//alert(this.text+ \"dom remove\")\n\t// If this widget has directly created DOM nodes, delete them and exit. This assumes that any child widgets are contained within the created DOM nodes, which would normally be the case\n\t$tw.utils.each(this.children,function(childWidget) {\n\t\t\tchildWidget.removeChildDomNodes();\n\t\t});\n\tif(this.domNodes.length > 0) {\n\t\t$tw.utils.each(this.domNodes,function(domNode) {\n\t\t\tdomNode.parentNode.removeChild(domNode);\n\t\t});\n\t\tthis.domNodes = [];\n\t}\n\tthis.delIdEventListeners([\n\t\t{ handler: this.handlename, id:this.Id+\"/mtm-play\"}\n\t]);\n};\n\n\nRevealWidget.prototype.handlesetvalEvent = function(event,aux) {\n\t//bj meditation: in the reduced case, the domnode with be passed here? or will be place in table?\n\t//the runtime will have to connect this up to the table up - better use table\n\tvar domNode = aux.domNode?aux.domNode:this.domNodes[0];\n\tthis[this.handler](event,aux, domNode);\n}\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nRevealWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn this.refreshChildren(changedTiddlers);\n\t}\n};\n\n\nexports[intra] = RevealWidget;//play\n\n})();\n",
            "title": "$:/mcore/modules/widgets/play.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/mcore/modules/widgets/play_handler.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/play_handler.js\ntype: application/javascript\nmodule-type: dom_method\n\n\\*/\n(function(){\nif ($tw.browser || typeof  $twmodules  !== \"undefined\") {\n\tvar channel_max = 10;\t\t\t\t\t\t\t\t\t\t// number of channels\n\tvar audiochannels = new Array();\n\tfor (var a=0;a<channel_max;a++) {\t\t\t\t\t\t\t\t\t// prepare the channels\n\t\taudiochannels[a] = new Array();\n\t\taudiochannels[a]['channel'] = new Audio();\t\t\t\t\t\t// create a new audio object\n\t\taudiochannels[a]['finished'] = -1;\t\t\t\t\t\t\t// expected end time for this channel\n\t}\n}\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nexports[\"py\"] = function(upstream,here,domNode) {\nvar node = domNode.firstElementChild;\nplay_multi_sound(node);\n//alert(domNode.firstElementChild.innerHTML )\n//alert(\"node = \"+ domNode.firstElementChild.Text )\n\tfunction play_multi_sound(node) {\n\n\t\tfor (var a=0;a<audiochannels.length;a++) {\n\t\t\tvar thistime = new Date();\n\t\t\tif (audiochannels[a]['finished'] < thistime.getTime()) {\t\t\t// is this channel finished?\n\t\t\t\taudiochannels[a]['finished'] = thistime.getTime() + node.duration*1000;\n\t\t\t\taudiochannels[a]['channel'].src = node.src;\n\t\t\t\taudiochannels[a]['channel'].load();\n\t\t\t\taudiochannels[a]['channel'].play();\n\t\t\t\t//alert(\"node = \"+node.src )\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n})();\n",
            "title": "$:/mcore/modules/widgets/play_handler.js",
            "type": "application/javascript",
            "module-type": "dom_method"
        },
        "$:/mcore/modules/widgets/popup_handler.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/popup_handler.js\ntype: application/javascript\nmodule-type: dom_method\n\n\n\\*/\n(function(){\nexports[\"do-popup\"] = function(upstream,here) {\n\n\t$tw.popup.triggerPopup({\n\t\tdomNode: upstream.domNode,\n\t\ttitle: here.popup,\n\t\tmsg: true,\n\t\twiki: null//not needed when sending msg\n\t});\n};\n})();\n",
            "title": "$:/mcore/modules/widgets/popup_handler.js",
            "type": "application/javascript",
            "module-type": "dom_method"
        },
        "$:/mcore/modules/widgets/sentmessage_handler.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/sentmessage_handler.js\ntype: application/javascript\nmodule-type: dom_method\n\nAction widget to send a message\n\n\\*/\n(function(){\nexports[\"as\"] = function(upstream,here) {\n\tvar data ={}, downsteamId;\n\tupstream= upstream?upstream:Object.create(null);\n\t// just passes data thru to the down stream, with overrides \n\t// Dispatch the message using the user supplied id/type - we are passing data onwards\n\tdownsteamId = here.sendId+'/'+here.sendType;\n\t//in this widget the 'here' only contains params to be pass forwards - override data passed from upstream\n\tfor (var attrname in upstream) { data[attrname] = upstream[attrname]; }\n\tfor (var attrname in here) { data[attrname] = here[attrname]; }\n\n\tthis.dispatchIdEvent(downsteamId,data);\n\n};\n})();\n",
            "title": "$:/mcore/modules/widgets/sentmessage_handler.js",
            "type": "application/javascript",
            "module-type": "dom_method"
        },
        "$:/mcore/modules/widgets/sentmessage.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/sentmessage.js\ntype: application/javascript\nmodule-type: widget\n\nAction widget to send a message\n\n\\*/\n(function(){\n//alert = function () {};\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nvar count = 0;\n\nvar Widget = require(\"$:/mcore/modules/widgets/event.js\").event;\n\nvar SendMessageWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\t\n\tthis.count = count++;\n};\n\n/*\nInherit from the base widget class\n*/\nSendMessageWidget.prototype = new Widget();\n\nSendMessageWidget.prototype.etype = \"click\"\n\nSendMessageWidget.prototype.wtype = \"action-sm\"\n\nSendMessageWidget.prototype.handler = \"as\";\n/*\nCompute the internal state of the widget\n*/\nSendMessageWidget.prototype.execute = function() {\n\tvar self = this;\n\n\tthis.here = Object.create(null);//hold the values for the dowmsteam dynamic\n\tthis.here.sendId = this.getAttribute(\"$sendOn\");\n\tthis.here.sendType = this.getAttribute(\"$action\");\n\n\t// Assemble the attributes as a hashmap\n\tthis.here.paramObject = Object.create(null);\n\t$tw.utils.each(this.attributes,function(attribute,name) {\n\t\tif(name.charAt(0) !== \"$\") {\n\t\t\tself.here.paramObject[name] = attribute;\n\t\t}\n\t});\n\n\tthis.here.tiddlerTitle = this.getVariable(\"currentTiddler\");\n\tthis.here.storyTiddler = this.getVariable(\"storyTiddler\");\n};\n\nexports[\"sentmessage\"] = SendMessageWidget;\n\n})();\n",
            "title": "$:/mcore/modules/widgets/sentmessage.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/core/modules/widgets/head_dom.js": {
            "text": "/*\\\ntitle: $:/core/modules/widgets/head_dom.js\ntype: application/javascript\nmodule-type: head_method\n\nAction start of static dom - in the head eare\n\n\\*/\nvar $twmodules = {}\n$twmodules.dom_method = {};\n$twmodules.animation = {};\n\n\n\t$tw = {};\n\t$tw.utils ={};\n\t$tw.anim ={};\nwindow.onload = function()\n//setTimeout(function()\n{\t\n \n\n\n\tvar mod = $twmodules.dom_method;\n\t//alert(\"load\")\n\t// first link to central table\n\tvar json = document.getElementById(\"jsontable\");//alert(json.textContent)\n\tvar action = JSON.parse(json.textContent); //alert(action[\"bt1/bjm-null\"])\n$tw.msgwidgettable = action;\n\t// Install the popup manager\n\t$tw.popup = new $tw.utils.Popup();\n\t$tw.domextra = new $tw.utils.domextra();\n\n// next connenct button clicks\n\tvar elements = document.getElementsByClassName(\"event\");//alert(elements.length)\n\tfor(var i=0; i<elements.length; i++) { \n\t\tvar j = 0;//alert(\"event\"+i)\n\t\tvar ev;\n\t\twhile ( ev = elements[i].getAttribute(\"data-event\"+j)) {//alert(ev)\n\t\t\tj++;\n\t\t\t(function (z,k) {\n\t\t\tvar ev = z;\n\t\t\tvar i = k;\n\t\t\telements[i].addEventListener(ev,function (event) {\n\t\t\t\tif (event.cancelable)  event.preventDefault();\n\t\t\t\t//the id and aux will need to be in the dom. - why is the aux used\n\t\t\t\tvar data = Object.create(null);\n\t\t\t\tdata.domNode = this;\n\t\t\t\tdata.e = event;\n\t\t\t\tdata.$isRef !== true; //indicate that we are sending references to objects\n\t\t\t\tmod.dispatchIdEvent(this.getAttribute(\"id\")+\"/mtm-\"+ev,data);\t\n\t\t\t\t//alert(this.getAttribute(\"id\")+\"/mtm-\"+ev) \n\t\t\t\treturn true;\n\t\t\t},false);\n\t\t\t\n\t\t\t})(ev,i);\n\t\t}\n\t}\n\t\n\t\n$tw.utils.getAnimationDuration =function () {return 400}\n\n $tw.anim.perform = function(type,domNode,options) {\n\toptions = options || {};\n\t// Find an animation that can handle this type\n\tvar chosenAnimation;\n\tif (type == \"open\") chosenAnimation= $twmodules.animation.slide.open;\n\telse if (type == \"close\") chosenAnimation= $twmodules.animation.slide.close;\n\tif(!chosenAnimation) {\n\t\tchosenAnimation = function(domNode,options) {\n\t\t\tif(options.callback) {\n\t\t\t\toptions.callback();\n\t\t\t}\n\t\t};\n\t}\n\t// Call the animation\n\tchosenAnimation(domNode,options);\n};\n\nmod.dispatchIdEvent = function(id, event) {\n\tvar listener = action[id], domNode;\n\twhile (listener) {\n//alert(listener.name.substring(0, 2)) \n\t\t//domNode indicates that we have a destination needing connecting to the dom\n\t\tif (('domNode' in listener.aux) && (!listener.aux['domNode'])) {\n\t\t\tlistener.aux['domNode'] = document.getElementById(listener.name);\n\t\t}\n\t\t//each widget needs to expose its dom modifying code via a naming convention\n\t\t//eg as = action set message,these are used to find their code in the reduced runtime\n\t\t//BJ meditiation we can use the non numeric part of the name instead of just the first two letter,\n\t\t//that will allow us to have user-defined methods. string.replace(searchvalue,newvalue)\n\t\tmod[listener.dom_method](event,listener.aux,listener.aux['domNode']);\n\t\tif(!listener.next) {\n\t\t\treturn true;\n\t\t}\n\t\tlistener = listener.next\n\t}\n\treturn true;\n}; \n\n}\n",
            "title": "$:/core/modules/widgets/head_dom.js",
            "type": "application/javascript",
            "module-type": "head_method"
        },
        "$:/mcore/modules/widgets/submit_handler.js": {
            "text": "/*\\\ntitle: $:/mcore/modules/widgets/submit_handler.js\ntype: application/javascript\nmodule-type: dom_method\n\\*/\n(function(){\nvar reduced = null;\nif (typeof $twmodules !== 'undefined') reduced = true;\n\nexports[\"do-submit\"] = function(upstream,here) {\n\tvar widget = this;\n\t\n\t   \n\tvar settimers = function(node,vals,title) {\n\tvar self = this;\n\tvar next = new Date(), timejson = {}, interval = 0, offset = 0;\n\tif (vals.timer1) interval = parseInt(vals.timer1);\n\t    if (interval > 0) {\n\t\tnext.setSeconds(next.getSeconds() + interval);\t\n\t\ttimejson.timeout = next.toJSON() ;\n\t\ttimejson.reps = vals.reps1-1;\n\t\ttimejson.dur = interval;\n\t\ttimejson.bell = vals.bell1;\t\t\n\t\ttimejson.onTimeout = function (){\n\t\t\tvar here = Object.create(null), \n\t\t\tdownsteamId = this.bell+'/'+\"mtm-play\";\n\t\t\there.text = \"\";\n\t\t\treduced?$twmodules.dom_method.dispatchIdEvent(downsteamId,here):widget.dispatchIdEvent(downsteamId,here);\n\t\t\tif (this.reps > 0) {\n\t\t\t\tvar next = new Date();\n\t\t\t\tnext.setSeconds(next.getSeconds() + this.dur);\t\n\t\t\t\tthis.timeout = next.toJSON();\n\t\t\t\tthis.reps--;\n\t\t\t\treturn this;\n\t\t\t} \n\t\t\t\n\t\t\t//if (i==1) return true;\n\t\t\t//return false;\n\t\t\n\t\t}.bind(timejson) ;\n\t\t\t$tw.utils.bjGlogalTimer.register(timejson);\n\t}\n\tnext = new Date();\n\ttimejson = {};\n\tinterval = (vals.timer2 ? parseInt(vals.timer2) : 0);\n\n\tif (interval> 0) {\n\t\tnext.setMinutes(next.getMinutes() + offset + interval);\t\n\t\toffset = offset + interval * vals.reps2;\n\t\ttimejson.timeout = next.toJSON() ;\n\t\ttimejson.reps = vals.reps2-1;\n\t\ttimejson.dur = interval;\n\t\ttimejson.bell = vals.bell2;\t\n\t\ttimejson.onTimeout = function (){\n\t\t\tvar here = Object.create(null), \n\t\t\tdownsteamId = this.bell+'/'+\"mtm-play\";\n\t\t\there.text = \"\";\n\t\t\treduced?$twmodules.dom_method.dispatchIdEvent(downsteamId,here):widget.dispatchIdEvent(downsteamId,here);\n\t\t\tif (this.reps > 0) {\n\t\t\t\tvar next = new Date();\n\t\t\t\tnext.setMinutes(next.getMinutes() + this.dur);\t\n\t\t\t\tthis.timeout = next.toJSON();\n\t\t\t\tthis.reps--;\n\t\t\t\treturn this;\n\t\t\t} \n\t\t\t\n\t\t\t//if (i==1) return true;\n\t\t\t//return false;\n\t\t\n\t\t}.bind(timejson) ;\n\t\t$tw.utils.bjGlogalTimer.register(timejson);\n\t}\n\tnext = new Date();\n\ttimejson = {};\n\tinterval = (vals.timer3 ? parseInt(vals.timer3) : 0);\n\n\tif (interval> 0) {\n\t\tnext.setMinutes(next.getMinutes() + offset + interval);\t\n\t\toffset = offset + interval * vals.reps3;\t\n\t\ttimejson.timeout = next.toJSON() ;\n\t\ttimejson.reps = vals.reps3-1;\n\t\ttimejson.dur = interval;\n\t\ttimejson.bell = vals.bell3;\n\t\ttimejson.onTimeout = function (){\n\t\t\tvar here = Object.create(null), \n\t\t\tdownsteamId = this.bell+'/'+\"mtm-play\";\n\t\t\there.text = \"\";\n\t\t\treduced?$twmodules.dom_method.dispatchIdEvent(downsteamId,here):widget.dispatchIdEvent(downsteamId,here);\n\t\t\tif (this.reps > 0) {\n\t\t\t\tvar next = new Date();\n\t\t\t\tnext.setMinutes(next.getMinutes() + this.dur);\t\n\t\t\t\tthis.timeout = next.toJSON();\n\t\t\t\tthis.reps--;\n\t\t\t\treturn this;\n\t\t\t} \n\t\t\t\n\t\t\t//if (i==1) return true;\n\t\t\t//return false;\n\t\t\n\t\t}.bind(timejson) ;\n\t\t$tw.utils.bjGlogalTimer.register(timejson);\n\t}\n\tnext = new Date();\n\ttimejson = {};\n\tinterval = (vals.timer4 ? parseInt(vals.timer4) : 0);\n\n\tif (interval> 0) {\n\t\tnext.setMinutes(next.getMinutes() + offset + interval);\t\n\t\toffset = offset + interval * vals.reps4;\n\t\ttimejson.timeout = next.toJSON() ;\n\t\ttimejson.reps = vals.reps4-1;\n\t\ttimejson.dur = interval;\n\t\ttimejson.bell = vals.bell4;\n\t\ttimejson.onTimeout = function (){\n\t\t\tvar here = Object.create(null), \n\t\t\tdownsteamId = this.bell+'/'+\"mtm-play\";\n\t\t\there.text = \"\";\n\t\t\treduced?$twmodules.dom_method.dispatchIdEvent(downsteamId,here):widget.dispatchIdEvent(downsteamId,here);\n\t\t\tif (this.reps > 0) {\n\t\t\t\tvar next = new Date();\n\t\t\t\tnext.setMinutes(next.getMinutes() + this.dur);\t\n\t\t\t\tthis.timeout = next.toJSON();\n\t\t\t\tthis.reps--;\n\t\t\t\treturn this;\n\t\t\t} \n\t\t\t\n\t\t\t//if (i==1) return true;\n\t\t\t//return false;\n\t\t\n\t\t}.bind(timejson) ;\n\t\t$tw.utils.bjGlogalTimer.register(timejson);\n\t}\n\t// now set up count down timer\n\ttimejson = {};\n\ttimejson.display = node.x;\n    timejson.start = Date.now();\n    timejson.duration = offset * 60;\n\n    timejson.onTick = function() {\n\t\tvar  diff,\n        minutes,\n        seconds;\n\n        diff = this.duration - (((Date.now() - this.start) / 1000) | 0);\n\n        minutes = (diff / 60) | 0;\n        seconds = (diff % 60) | 0;\n\n        minutes = minutes < 10 ? \"0\" + minutes : minutes;\n        seconds = seconds < 10 ? \"0\" + seconds : seconds;\n\n        this.display.textContent = minutes + \":\" + seconds; \n\n        if (diff <= 0) {\n\t\t\treturn true;\n        }\n    }.bind(timejson) ;\n\t$tw.utils.bjGlogalTimer.register(timejson);\n\t//$tw.wiki.setTiddlerData (title,vals);\n}\n\tvar vals = $tw.domextra.serialize(upstream.domNode, upstream.e);\n\tsettimers(upstream.domNode, vals, here.tiddler);\n\t//alert(JSON.stringify(vals))//$tw.wiki.setTiddlerData (here.tiddler,vals); \n};\n})();\n",
            "title": "$:/mcore/modules/widgets/submit_handler.js",
            "type": "application/javascript",
            "module-type": "dom_method"
        },
        "$:/core/modules/widgets/tablereset.js": {
            "text": "/*\\\ntitle: $:/core/modules/widgets/tablereset.js\ntype: application/javascript\nmodule-type: widget\n\ncreate a json tiddler containing the msg table\n* \n\\*/\n(function(){\n//var count = 0;\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar SendMessageWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nSendMessageWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nSendMessageWidget.prototype.render = function(parent,nextSibling) {\nthis.resetTable();\n};\n\n/*\nCompute the internal state of the widget\n*/\nSendMessageWidget.prototype.execute = function() {\n\n};\n\n/*\nRefresh the widget by ensuring our attributes are up to date\n*/\nSendMessageWidget.prototype.refresh = function(changedTiddlers) {\n\n\treturn this.refreshChildren(changedTiddlers);\n};\n\n\n\nexports[\"tablereset\"] = SendMessageWidget;\n\n})();\n",
            "title": "$:/core/modules/widgets/tablereset.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/core/modules/widgets/tableset.js": {
            "text": "/*\\\ntitle: $:/core/modules/widgets/tableset.js\ntype: application/javascript\nmodule-type: widget\n\ncreate a json tiddler containing the msg table\n* \n\\*/\n(function(){\n//var count = 0;\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/bj/modules/widgets/msgwidget.js\").msgwidget;\n\nvar SendMessageWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nSendMessageWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nSendMessageWidget.prototype.render = function(parent,nextSibling) {\nthis.setTable();\n};\n\n/*\nCompute the internal state of the widget\n*/\nSendMessageWidget.prototype.execute = function() {\n\n};\n\n/*\nRefresh the widget by ensuring our attributes are up to date\n*/\nSendMessageWidget.prototype.refresh = function(changedTiddlers) {\n\n\treturn this.refreshChildren(changedTiddlers);\n};\n\n\n\nexports[\"tableset\"] = SendMessageWidget;\n\n})();\n",
            "title": "$:/core/modules/widgets/tableset.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/mcore/templates/exporters/StaticBottomAndTable": {
            "title": "$:/mcore/templates/exporters/StaticBottomAndTable",
            "text": "{{{[all[shadows+tiddlers]tag[$:/tags/BelowStory]!has[draft.of]]||$:/core/templates/html-tiddler}}}\n\n\n"
        },
        "$:/mcore/templates/exporters/StaticRiver": {
            "title": "$:/mcore/templates/exporters/StaticRiver",
            "tags": "$:/tags/Exporter",
            "description": "{{$:/language/Exporters/StaticRiver}}",
            "extension": ".html",
            "text": "\\define tv-wikilink-template() #$uri_encoded$\n\\define tv-config-toolbar-icons() no\n\\define tv-config-toolbar-text() no\n\\define tv-config-toolbar-class() tc-btn-invisible\n\\rules only filteredtranscludeinline transcludeinline\n<!doctype html>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />\n<meta name=\"generator\" content=\"TiddlyWiki\" />\n<meta name=\"tiddlywiki-version\" content=\"{{$:/core/templates/version}}\" />\n<meta name=\"format-detection\" content=\"telephone=no\">\n<link id=\"faviconLink\" rel=\"shortcut icon\" href=\"favicon.ico\">\n<title>{{$:/core/wiki/title}}</title>\n<div id=\"styleArea\">\n{{$:/boot/boot.css||$:/core/templates/css-tiddler}}\n</div>\n<style type=\"text/css\">\n{{$:/core/ui/PageStylesheet||$:/core/templates/wikified-tiddler}}\n</style>\n{{{ [all[shadows+tiddlers]module-type[head_method]] ||$:/core/templates/javascript-tiddler}}}\n</head>\n<body class=\"tc-body\">\n{{$:/core/templates/exporters/StaticRiver/tableset}}\n{{$:/StaticBanner||$:/core/templates/html-tiddler}}\n{{{[all[shadows+tiddlers]tag[$:/tags/AboveStory]!has[draft.of]]||$:/core/templates/html-tiddler}}}\n\n<section class=\"tc-story-river\">\n{{$:/core/templates/exporters/StaticRiver/Content||$:/core/templates/html-tiddler}}\n\n</section> \n{{$:/StaticBottom||$:/core/templates/html-tiddler}}\n{{{[all[shadows+tiddlers]tag[$:/tags/BelowStory]!has[draft.of]]||$:/core/templates/html-tiddler}}}\n{{$:/core/templates/exporters/StaticRiver/table}}\n{{$:/core/templates/exporters/jsonRiver}}\n{{{ [[dom_method]] [[animation]] ||$:/mcore/templates/modules}}}\n{{$:/core/modules/utils/utils.js||$:/core/templates/javascript-tiddler-popup}}\n{{$:/core/modules/utils/dom/browser.js||$:/core/templates/javascript-tiddler-popup}}\n{{$:/core/modules/utils/dom/popup.js||$:/core/templates/javascript-tiddler-popup}}\n{{$:/core/modules/utils/dom.js||$:/core/templates/javascript-tiddler-popup}}\n{{$:/mcore/modules/utils/dom/extra.js||$:/core/templates/javascript-tiddler-popup}}\n{{$:/mcore/modules/utils/dom/timer.js||$:/core/templates/javascript-tiddler-popup}}\n</body>\n</html>\n"
        },
        "$:/core/templates/exporters/StaticRiver/ContentAndTable": {
            "title": "$:/core/templates/exporters/StaticRiver/ContentAndTable",
            "text": "\\define renderContent()\n{{{ $(exportFilter)$ ||$:/core/templates/static-tiddler}}}\n\\end\n<$importvariables filter=\"[[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]\">\n<<renderContent>>\n</$importvariables>\n<$msgexport tiddler=\"$:/temp/__priv__/transientTableEvents\"/>\n\n"
        },
        "$:/core/templates/javascript-tiddler-modtype": {
            "title": "$:/core/templates/javascript-tiddler-modtype",
            "text": "<!--\n\nThis template is used for saving JavaScript tiddlers as a script tag with data attributes representing the tiddler fields.\n\n-->`<script`<$fields template=' data-tiddler-$name$=\"$encoded_value$\"'></$fields>` type=\"text/javascript\"> (function (exports){`<$view field=\"text\" format=\"text\" />`})($twmodules.`<<module>>`);</script>`\n"
        },
        "$:/core/templates/javascript-tiddler-popup": {
            "title": "$:/core/templates/javascript-tiddler-popup",
            "text": "<!--\n\nThis template is used for saving JavaScript tiddlers as a script tag with data attributes representing the tiddler fields.\n\n-->`<script`<$fields template=' data-tiddler-$name$=\"$encoded_value$\"'></$fields>` type=\"text/javascript\"> (function (exports){`<$view field=\"text\" format=\"text\" />`})($tw.utils);</script>`\n"
        },
        "$:/core/templates/json-tiddler": {
            "title": "$:/core/templates/json-tiddler",
            "text": "<!--\n\nThis template is used for saving JavaScript tiddlers as a script tag with data attributes representing the tiddler fields.\n\n-->`<script`<$fields template=' data-tiddler-$name$=\"$encoded_value$\"'></$fields>` id=\"jsontable\" type=\"application/json\">`<$view field=\"text\"  format=\"text\" />`</script>`\n"
        },
        "$:/core/templates/exporters/jsonRiver": {
            "created": "20150725090158641",
            "modified": "20150725090942455",
            "tags": "",
            "title": "$:/core/templates/exporters/jsonRiver",
            "type": "text/vnd.tiddlywiki",
            "text": "\\define renderContent()\n{{{ $(exportFilterJson)$ ||$:/core/templates/json-tiddler}}}\n\\end\n<$importvariables filter=\"[[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]\">\n<<renderContent>>\n</$importvariables>\n"
        },
        "$:/mcore/templates/modules": {
            "title": "$:/mcore/templates/modules",
            "text": "<$set name=module value=<<currentTiddler>> >\n{{{ [all[shadows+tiddlers]module-type<currentTiddler>] ||$:/core/templates/javascript-tiddler-modtype}}}\n</$set>\n"
        },
        "$:/mcore/templates/namedmod": {
            "title": "$:/mcore/templates/namedmod",
            "text": "<$set name=modtype value=<<currentTiddler>> >\n{{{ [<currentTiddler>] ||$:/mcore/templates/modules}}}\n</$set>\n"
        },
        "$:/core/templates/static-tiddler": {
            "title": "$:/core/templates/static-tiddler",
            "text": "<a name=<<currentTiddler>>></a>\n<$transclude tiddler=\"$:/core/ui/ViewTemplate/body\"/>\n"
        },
        "$:/core/templates/exporters/StaticRiver/table": {
            "title": "$:/core/templates/exporters/StaticRiver/table",
            "text": "<$msgexport tiddler=\"$:/temp/__priv__/transientTableEvents\"/>\n<$tablereset/>\n"
        },
        "$:/core/templates/exporters/StaticRiver/tableset": {
            "title": "$:/core/templates/exporters/StaticRiver/tableset",
            "text": "<$tableset/>\n"
        },
        "$/mcore/templates/testing": {
            "title": "$/mcore/templates/testing",
            "type": "text/vnd.tiddlywiki",
            "text": "<!-- This template is provided for backwards compatibility with older versions of TiddlyWiki -->\n\n<$set name=\"exportFilter\" value=\"[tag[testtiddlers]]\">\n<$set name=\"exportFilterJson\" value=\"[[$:/temp/__priv__/transientTableEvents]]\">\n\n{{$:/mcore/templates/exporters/StaticRiver}}\n\n</$set> \n</$set> \n"
        },
        "$:/bj/modules/widgets/widget-extend.js": {
            "text": "/*\\\ntitle: $:/bj/modules/widgets/widget-extend.js\ntype: application/javascript\nmodule-type: widget\n\nExtend the dropzone widget to allow other widget to handle drop events \n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n//call depth first removal - facilitates final functionality of widgets\nWidget.prototype.removeChildDomNodes = function() {\n\t$tw.utils.each(this.children,function(childWidget) {\n\t\tchildWidget.removeChildDomNodes();\n\t});\n\t// If this widget has directly created DOM nodes, delete them and exit. This assumes that any child widgets are contained within the created DOM nodes, which would normally be the case\n\tif(this.domNodes.length > 0) {\n\t\t$tw.utils.each(this.domNodes,function(domNode) {\n\t\t\tdomNode.parentNode.removeChild(domNode);\n\t\t});\n\t\tthis.domNodes = [];\n\t} else {\n\t\t// Otherwise, ask the child widgets to delete their DOM nodes\n\n\t}\n};\n\n})();\n",
            "title": "$:/bj/modules/widgets/widget-extend.js",
            "type": "application/javascript",
            "module-type": "widget"
        }
    }
}